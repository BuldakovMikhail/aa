\chapter{Технологическая часть}

В данном разделе будут приведены требования к программному обеспечению, средства реализации, листинг кода и функциональные тесты.

\section{Средства реализации}

Для реализации данной работы был выбран язык \textit{Python}~\cite{python}. Такой выбор обусловлен опытом работы с этим языком программирования. Также данный язык позволяет замерять процессорное время с помощью модуля \textit{time}.

Время работы было замерено с помощью функции \textit{process\_time\_ns()} из модуля \textit{time}~\cite{python-time}.

\section{Реализация алгоритмов}

В листингах \ref{lst:lev_mtr} -- \ref{lst:dameray_lev_rec_hash} приведены реализации алгоритмов поиска расстояний Левенштейна (только нерекурсивный алгоритм) и Дамерау-Левенштейна (нерекурсивный, рекурсивный и рекурсивный с кешированием).

\clearpage

\begin{lstlisting}[label=lst:lev_mtr,caption=Функция нахождения расстояния Левенштейна с использованием матрицы]
def m(a, b):
	return 0 if a == b else 1


def levenstein(s1, s2):
	matrix = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]
	for i in range(len(matrix)):
		for j in range(len(matrix[0])):
			if i == 0 and j == 0:
				matrix[i][j] = 0
			elif i > 0 and j == 0:
				matrix[i][j] = i
			elif j > 0 and i == 0:
				matrix[i][j] = j
			else:
				matrix[i][j] = min([matrix[i][j - 1] + 1, matrix[i-1][j] + 1, matrix[i - 1][j - 1] + m(s1[i-1], s2[j-1])])
	return matrix[-1][-1]
\end{lstlisting}

\clearpage

\begin{lstlisting}[label=lst:dameray_lev_rec,caption=Функция нахождения расстояния Дамерау-Левенштейна с использованием матрицы]
def damerau_levenstein_iter(s1, s2):
	d = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]
	for i in range(len(d)):
		for j in range(len(d[0])):
			if i == 0 and j == 0:
				d[i][j] = 0
			elif i > 0 and j == 0:
				d[i][j] = i
			elif j > 0 and i == 0:
				d[i][j] = j
			elif i > 1 and j > 1 and s1[i-1] == s2[j-2] and s1[i-2] == s2[j-1]:
				d[i][j] = min([d[i][j-1] + 1, d[i-1][j] + 1, d[i-1][j-1] + m(s1[i-1], s2[j-1]), d[i-2][j-2] + 1])
			else:
				d[i][j] = min([d[i][j - 1] + 1, d[i-1][j] + 1, d[i - 1][j - 1] + m(s1[i-1], s2[j-1])])
	return d[-1][-1]
\end{lstlisting}

\clearpage

\begin{lstlisting}[label=lst:dameray_lev_mtr,caption=Функция нахождения расстояния Дамерау-Левенштейна рекурсивно]
def damerau_levenstein_rec(s1, s2):
	if len(s1) == 0 or len(s2) == 0:
		return max(len(s1), len(s2))
	temp = min([damerau_levenstein_rec(s1[:-1], s2) + 1, damerau_levenstein_rec(s1, s2[:-1]) + 1, damerau_levenstein_rec(s1[:-1], s2[:-1]) + m(s1[-1], s2[-1])])

	if len(s1) > 1 and len(s2) > 1 and s1[-1] == s2[-2] and s1[-2] == s2[-1]:
		temp = min(temp, damerau_levenstein_rec(s1[:-2], s2[:-2]) + 1)

	return temp
\end{lstlisting}

\clearpage

\begin{lstlisting}[label=lst:dameray_lev_rec_hash,caption=Функция нахождения расстояния Дамерау-Левенштейна рекурсивно c кешированием]
def damerau_levenstein_rec_cash(s1, s2):
	d = [[-1] * (len(s2) + 1) for _ in range(len(s1) + 1)]

	def dlrc(s1, s2):
		if len(s1) == 0 or len(s2) == 0:
			d[len(s1)][len(s2)] = max(len(s1), len(s2))
			return d[len(s1)][len(s2)]

		if d[len(s1[:-1])][len(s2)] >= 0:
			dlr1 = d[len(s1[:-1])][len(s2)]
		else:
			# Случай если значение не в кеше, то вычисляем и "кешируем"
			dlr1 = dlrc(s1[:-1], s2)
			d[len(s1[:-1])][len(s2)] = dlr1

		if d[len(s1)][len(s2[:-1])] >= 0:
			dlr2 = d[len(s1)][len(s2[:-1])]
		else:
			# Случай если значение не в кеше, то вычисляем и "кешируем"
			dlr2 = dlrc(s1, s2[:-1])
			d[len(s1)][len(s2[:-1])] = dlr2

		if d[len(s1[:-1])][len(s2[:-1])] >= 0:
			dlr3 = d[len(s1[:-1])][len(s2[:-1])]
		else:
			# Случай если значение не в кеше, то вычисляем и "кешируем"
			dlr3 = dlrc(s1[:-1], s2[:-1])
			d[len(s1[:-1])][len(s2[:-1])] = dlr3

		temp = min([dlr1 + 1, dlr2 + 1, dlr3 + m(s1[-1], s2[-1])])

		if len(s1) > 1 and len(s2) > 1 and s1[-1] == s2[-2] and s1[-2] == s2[-1]:
			if d[len(s1[:-2])][len(s2[:-2])] >= 0:
				dlr4 = d[len(s1[:-2])][len(s2[:-2])]
			else:
				# Случай если значение не в кеше, то вычисляем и "кешируем"
				dlr4 = dlrc(s1[:-2], s2[:-2])
				d[len(s1[:-2])][len(s2[:-2])] = dlr4
			temp = min(temp, dlr4 + 1)

		d[len(s1)][len(s2)] = temp

		return temp

	return dlrc(s1, s2)
\end{lstlisting}

\clearpage


\section{Функциональные тесты}

В таблице \ref{tbl:func_tests} приведены функциональные тесты для алгоритмов вычисления расстояний Левенштейна и Дамерау—Левенштейна. Все тесты пройдены успешно.

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
		\caption{Функциональные тесты}
		\label{tbl:func_tests}
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			\multicolumn{2}{|c|}{\bfseries Входные данные}
			& \multicolumn{4}{c|}{\bfseries Расстояние и алгоритм} \\ 
			\hline 
			&
			& \multicolumn{1}{c|}{\bfseries Левенштейна} 
			& \multicolumn{3}{c|}{\bfseries Дамерау-Левенштейна} \\ \cline{3-6}
			
			\bfseries Строка 1 & \bfseries Строка 2 & \bfseries Итеративный & \bfseries Итеративный
			
			& \multicolumn{2}{c|}{\bfseries Рекурсивный} \\ \cline{5-6}
			& & & & \bfseries Без кеша & \bfseries С кешом \\
			\hline
			$\lambda$ & $\lambda$ & 0 & 0 & 0 & 0 \\
			\hline
			a & b & 1 & 1 & 1 & 1 \\
			\hline
			a & a & 0 & 0 & 0 & 0 \\
			\hline
			кот & скат & 2 & 2 & 2 & 2 \\
			\hline
			ab & ba & 2 & 1 & 1 & 1 \\
			\hline
			bba & abba & 1 & 1 & 1 & 1 \\
			\hline
			aboba & boba & 1 & 1 & 1 & 1 \\
			\hline
			abcdef & gh & 6 & 6 & 6 & 6 \\
			\hline
			
		\end{tabular}	
		\end{threeparttable}
	\end{center}
\end{table}

\section*{Вывод}

Были реализованы алгоритмы поиска расстояния Левенштейна итеративно, поиска расстояния Дамерау–Левенштейна итеративно, рекурсивно и рекурсивно с кешированием. Проведено тестирование реализаций алгоритмов.
