\chapter{Конструкторский раздел}

В этом разделе будет представлено описание используемых типов данных, а также схемы алгоритмов исправления орфографических ошибок.

\section{Требования к программному обеспечению}

Программа должна поддерживать два режима работы: режим массового замера времени и режим исправления введенного слова.

Режим массового замера времени должен обладать следующей функциональностью:
\begin{itemize}
	\item генерировать корпус слов;
	\item осуществлять массовый замер, используя сгенерированные данные;
	\item результаты массового замера должны быть представлены в виде таблицы.
\end{itemize}

К режиму исправления введенного слова выдвигается следующий ряд требований:
\begin{itemize}
	\item возможность вводить слова, которые отсутствуют в корпусе;
	\item слова вводятся на кириллице;
	\item наличие интерфейса для выбора действий;
	\item на выходе программы, набор из самых близких слов к введенному.
\end{itemize}

\section{Описание используемых типов данных}

При реализации алгоритмов будут использованы следующие структуры
и типы данных:
\begin{itemize}
	\item слово --- массив букв;
	\item корпус --- массив слов, отсортированный в лексикографическом порядке;
	\item сегментированный словарь --- словарь, где ключом является буква, а значением корпус;
	\item мьютекс --- примитив синхронизации.
\end{itemize}


\section{Разработка алгоритмов}


На рисунке \ref{img:segmented} представлена схема поиска ближайших слов в словаре, алгоритм одинаков в случае если используются потоки и если не используются, поскольку потоки применяются только для поиска слов в корпусе. 
На рисунке \ref{img:algomain} представлена схема поиска ближайших слов в корпусе без использования потоков. 
На рисунке \ref{img:algomainmt} представлена схема поиска ближайших слов в корпусе с использованием потоков. 
На рисунке \ref{img:threadfunc} представлена схема алгоритма программы, выполняющейся в потоке. 


\includeimage
{segmented} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма поиска ближайших слов в сегментированном словаре} % Подпись рисунка


\includeimage
{algomain} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма поиска ближайших слов в корпусе} % Подпись рисунка


\includeimage
{algomainmt} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{0.8\textwidth} % Ширина рисунка
{Схема многопоточного алгоритма поиска ближайших слов в корпусе} % Подпись рисунка


\includeimage
{threadfunc} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Схема алгоритма потока} % Подпись рисунка


Поскольку в массиве в каждый момент времени содержатся слова, которые находятся на одинаковом расстоянии от введенного слова, то нет необходимости в какой-либо сортировке результатов, т.~к. любое из найденных слов с одинаковой вероятностью может оказаться искомым. Поэтому шаг особого слияния результатов не требуется и достаточно помещать подходящее слово в массив.

\section*{Вывод}
На основе теоретических данных, полученных из аналитического раз-
дела были построены схемы требуемых алгоритмов. 